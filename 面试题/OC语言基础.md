###### 1. Objective-C 的优缺点有哪些？

优点：

1. Objective-C 是C语言的超集，在C语言的基础上衍生了很多新的语言特征，封装得很完善而且方便使用，大大降低了编程复杂度，因此开发中使用起来会感觉方便高效。
2. Category(类别)的使用，可以快速扩展类的方法，同时使扩展的功能模块之间互不影响。
3. Posing(扮演)特性，[ParentClass poseAs:[ChildrenClass class]];该语言特性使得父类无须定义和初始化子类对象，即可通过父类扮演子类进行操作。
4. 动态语言特性，动态类型、动态绑定和动态加载，将类型确定、方法调用和资源加载等任务推迟到运行时，大大提高了编程灵活度。
5. 指针：Objective-C保留了C语言强大的指针特性。
6. Objective-C与C/C++可在.mm文件中进行混合编程，灵活度更高。

缺点:

1. 不支持命名空间(都是通过加一些像NS或者UI这样的命名前缀来达到用命名空间防止命名冲突的作业，但这样会使变量的命名更长)
2. 不支持运算符重载
3. 不支持多继承
4. 使用动态运行时类型，所有的方法都是通过消息传递机制方法调用，有其动态的优势，同时也使很多编译时的优化方法无法使用降低了性能。



###### 2.相对于Objective-C而言，Swift有什么新特性？

1. 安全：有严格的类型检查
2. 强大：有高度优化的LLVM编译器。
3. 新型：Swift借鉴多种语言特性，表达更简单精确。



###### 3. Foundation对象与Core Foundation对象有什么区别

Foundation对象是Objective-C对象，使用Objective-C语言实现；

而Core Foundation对象是C对象，使用C语言实现。

两者之间可以通过__bridge、__bridge_transfer、__bridge_retained等关键字转换（桥接）。

在非ARC下两者都需要开发者手动管理内存，没有区别。

在ARC下，系统只会自动管理Foundation对象的释放，而不支持对Core Foundation对象的管理。因此，在ARC下两者进行转换后，必须要确定转换后的对象是由开发者手动管理，还是由ARC系统继续管理，否则可能导致内存泄漏问题。



###### 4.Objective-C中的类方法和实例方法有什么本质区别和联系

1. 类方法属于类对象，用“+”号修饰，它类似于C语言中的静态方法，类方法列表定义在类对象的元类中，通过isa指针找到；实例方法属于实例对象，用“-”号修饰，实例方法列表定义在实例对象的类对象中，通过isa指针找到。
2. 类方法只能通过类对象调用，也就是类名直接调用；实例方法则需要由通过alloc和init方法实例化后的实例对象调用。
3. 类方法中的self指类对象；实例方法中的self指实例对象。
4. 类方法可以调用其他的类方法，但不可以直接调用实例方法；而实例方法既可以调用其他实例方法，也可以通过类名直接调用本类或者外部类的类方法。
5. 在实例方法中可以访问成员变量，但类方法中不能访问成员变量。



###### 5.子类初始化时为什么要调用self=[superinit]

因为子类继承自父类，需要获得父类的实例和方法等，所以初始化子类之前要先保证父类已经初始化完毕，防止出错。当调用self=[super init]方法时，如果父类初始化不成功，那么会返回nil，所以可以根据self是否为nil判断父类是否初始化成功，从而进行合理地处理，以便起到容错效果。



###### 6.使用dealloc方法释放对象时，为什么一定要调用[superdealloc]方法?在何处调用?

因为子类的很多实例变量是继承自父类的，所以要调用[superdealloc]方法来释放从父类继承来的实例变量，实际上还是释放自己的实例变量，只是继承来的这部分只能调用父类的dealloc方法来释放。

按照自下往上的逻辑，一般要先释放子类的实例，然后释放父类的实例。自下往上的原因是，在调用[super dealloc]方法之前如果不先把子类中的变量从内存中释放掉，容易造成子类中变量的内存积压，导致内存泄漏，所以[super dealloc]方法应该在释放掉子类变量之后最后调用。



###### 7. ＃import与＃include以及＃import<>与＃import""各有什么区别

import与#include都是用来引入头文件的。与#include相比，Objective-C中#import的优势是不会引起重复包含，相当于多了C/C++中#pragma once的作用，它可以保证头文件只被编译一次。

import<>与#import""的区别和C/C++中#include<>与#include""的区别一样：使用尖括号<>指用来引入系统的头文件，而使用引号" "指用来引入本地用户头文件。



###### 8.Objective-C中@class代表什么

@class相当于只是在头文件声明一下要用到的类的头文件（前向声明），告诉编译器有这样一个类的定义但暂时不要将类的实现引入，让该类定义的变量能够编译通过，直到运行起来时才去查看类的实现文件。但实际上这样也只能起到在头文件中声明该类实例变量的作用，在.m文件中如果用到类的实现细节（属性和方法），那么还是要通过#import再次引入类的头文件。

使用@class的好处是将头文件的引入延迟了，至少延迟到了.m实现文件中，这也符合“直到真正用到的时候再确定引入”的动态思想，尽量往后拖延，更重要的是这样也可以有效地避免头文件的重复引入甚至循环引用等问题。



###### 9.Objective-C中有二维数组吗？如何实现

Objective-C中是没有二维数组的。二维数组是通过一维数组的嵌套实现的。



###### 10.在Objective-C的数组或字典中，添加nil对象会有什么问题

数组或字典如果通过addObject方法添加nil，那么程序会崩溃。

但如果使用initWith Objects方法来初始化数组，其中的nil会被编译器过滤去掉，不会出现崩溃问题。

另外，如果使用糖衣语法初始化数组或字典，那么也不可以有nil，此时nil不会被过滤掉也会导致程序崩溃。



###### 11. Objective-C中的可变和不可变类型是什么？

Objective-C中的mutable和immutable类型对应于动态空间分配和静态空间分配。



###### 12.以下这个写法会出什么问题?

```
@property(nonatomic, copy) NSMutableArray *array;
```

这里可变数组变量的内存管理语义修饰词设置为copy，而使用copy策略复制出来的是一个NSArray不可变数组对象，把copy出来的不可变数组对象当成可变数组对象使用容易造成程序崩溃。



###### 13. 在Objective-C中，常量有哪几种类型

1. 整型常量
2. 浮点型常量
3. 字符常量
4. 符号常量(#define 标识符常量)



###### 14. 常量和变量有什么区别?

在Objective-C中，用来指代数据的值有可变和不可变之分。

常量表示一些固定的、不会被修改的数据。反之，能改变的数据的值就称为变量。



###### 15. Objective-C中的NSInteger类型和C语言中的int类型有什么区别

在Objective-C中，数据类型可以分为基本数据类型、对象类型和id类型。

基本数据类型有int类型、float类型、double类型、char类型、布尔类型等。

事实上，Objective-C中的NSInteger也是基本数据类型之一。

在苹果的API实现中，NSInterger是一个对int类型和long类型的封装，它会识别当前操作系统的位数，自动返回最大的类型。

NSInteger是long或者int的别名，对应的NSUInteger是unsigned long或者unsigned int的别名。区别在于，NSInteger会根据系统是32位机还是64位机来动态确定自身是整型还是长整型，从而可以很好地兼容两种机器。因此，当开发者不知道操作系统是什么类型的时候，通常应该使用NSInteger，这也是苹果公司推荐使用的基本数据类型之一。

NSInteger是Objective-C基本数据类型，不是NSNumber的子类，也不是NSObject的子类。



###### 16. NSNumber与NSInteger有什么区别

NSInteger和NSNumber最本质的区别是：NSInteger不是一个对象，而是基本数据类型的typedef（也就是基本数据类型另外的一个名称）。它实际上是64位的long或者32位的int。

如果需要存储一个数值（如将一个int类型的值存入数组），那么直接使用NSInterger是不行的，必须使用NSNumber类将基本数据类型包装成对象。



###### 17. nil、NIL、NSNULL 有什么区别？

* nil、NIL 可以说是等价的，都代表内存中一块空地址。
* NSNULL 代表一个指向 nil 的对象。



###### 18. 如何实现一个线程安全的 NSMutableArray?

NSMutableArray是线程不安全的，当有多个线程同时对数组进行操作的时候可能导致崩溃或数据错误

* 线程锁：使用线程锁对数组读写时进行加锁
* 派发队列：在《Effective Objective-C 2.0..》书中第41条：多用派发队列，少用同步锁中指出：使用“串行同步队列”（serial synchronization queue），将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD的栅栏块（barrier）来不仅实现数据同步线程安全，还比串行同步队列方式更高效。



###### 19. atomic 修饰的属性是绝对安全的吗？为什么？

不是，所谓的安全只是局限于 Setter、Getter 的访问器方法而言的，你对它做 Release 的操作是不会受影响的。这个时候就容易崩溃了。



###### 20. 实现 isEqual 和 hash 方法时要注意什么？

* hash

  对关键属性的hash值进行位或运算作为hash值

* isEqual

  ==运算符判断是否是同一对象, 因为同一对象必然完全相同

  判断是否是同一类型, 这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险

  判断对象是否是nil, 做参数有效性检查

  各个属性分别使用默认判等方法进行判断

  返回所有属性判等的与结果





###### 21. id 和 instanceType 有什么区别？

* 相同点

  nstancetype 和 id 都是万能指针，指向对象。

* 不同点

  1. id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。
  2. id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型。



###### 22. self和super的区别

* self调用自己方法，super调用父类方法

* self是类，super是预编译指令

* [self class] 和 [super class] 输出是一样的

* self和super底层实现原理

  * 当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；

    而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法

  * 当使用 self 调用时，会使用 objc_msgSend 函数：

    ```
    id objc_msgSend(id theReceiver, SEL theSelector, ...
    ```

    第一个参数是消息接收者，第二个参数是调用的具体类方法的 selector，后面是 selector 方法的可变参数。以 [self setName:] 为例，编译器会替换成调用 objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。

    

  * 当使用 super 调用时，会使用 objc_msgSendSuper 函数：

    ```
    id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
    ```

  * 第一个参数是个objc_super的结构体，第二个参数还是类似上面的类方法的selector

    ```
    struct objc_super {
    	id receiver;
    	Class superClass;
    };
    ```





###### 23. 类族

系统框架中有许多类簇，大部分collection类都是类族。例如NSArray与其可变版本NSMutableArray。这样看来实际上有两个抽象基类，一个用于不可变数组，一个用于可变数组。尽管具备公共接口的类有两个，但任然可以合起来算一个类族。不可变的类定义了对所有数组都通用的方法，而可变类则定义了那些只适用于可变数组的方法。两个类共同属于同一个类族，这意味着二者在实现各自类型的数组时可以共用实现代码，此外还能把可变数组复制成不可变数组，反之亦然。



###### 24.iOS内存分区情况

* 栈区（Stack

  由编译器自动分配释放，存放函数的参数，局部变量的值等

  栈是向低地址扩展的数据结构，是一块连续的内存区域

* 堆区（Heap

  由程序员分配释放

  是向高地址扩展的数据结构，是不连续的内存区域

* 全局区

  全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域

  程序结束后由系统释放

* 常量区

  常量字符串就是放在这里的

  程序结束后由系统释放

* 代码区

  存放函数体的二进制代码

* 注：

  * 在 iOS 中，堆区的内存是应用程序共享的，堆中的内存分配是系统负责的
  * 系统使用一个链表来维护所有已经分配的内存空间（系统仅仅记录，并不管理具体的内容）
  * 变量使用结束后，需要释放内存，OC 中是判断引用计数是否为 0，如果是就说明没有任何变量使用该空间，那么系统将其回收
  * 当一个 app 启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）























