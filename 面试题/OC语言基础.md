###### 1. Objective-C 的优缺点有哪些？

优点：

1. Objective-C 是C语言的超集，在C语言的基础上衍生了很多新的语言特征，封装得很完善而且方便使用，大大降低了编程复杂度，因此开发中使用起来会感觉方便高效。
2. Category(类别)的使用，可以快速扩展类的方法，同时使扩展的功能模块之间互不影响。
3. Posing(扮演)特性，[ParentClass poseAs:[ChildrenClass class]];该语言特性使得父类无须定义和初始化子类对象，即可通过父类扮演子类进行操作。
4. 动态语言特性，动态类型、动态绑定和动态加载，将类型确定、方法调用和资源加载等任务推迟到运行时，大大提高了编程灵活度。
5. 指针：Objective-C保留了C语言强大的指针特性。
6. Objective-C与C/C++可在.mm文件中进行混合编程，灵活度更高。

缺点:

1. 不支持命名空间(都是通过加一些像NS或者UI这样的命名前缀来达到用命名空间防止命名冲突的作业，但这样会使变量的命名更长)
2. 不支持运算符重载
3. 不支持多继承
4. 使用动态运行时类型，所有的方法都是通过消息传递机制方法调用，有其动态的优势，同时也使很多编译时的优化方法无法使用降低了性能。



###### 2.相对于Objective-C而言，Swift有什么新特性？

1. 安全：有严格的类型检查
2. 强大：有高度优化的LLVM编译器。
3. 新型：Swift借鉴多种语言特性，表达更简单精确。



###### 3. Foundation对象与Core Foundation对象有什么区别

Foundation对象是Objective-C对象，使用Objective-C语言实现；

而Core Foundation对象是C对象，使用C语言实现。

两者之间可以通过__bridge、__bridge_transfer、__bridge_retained等关键字转换（桥接）。

在非ARC下两者都需要开发者手动管理内存，没有区别。

在ARC下，系统只会自动管理Foundation对象的释放，而不支持对Core Foundation对象的管理。因此，在ARC下两者进行转换后，必须要确定转换后的对象是由开发者手动管理，还是由ARC系统继续管理，否则可能导致内存泄漏问题。



###### 4.Objective-C中的类方法和实例方法有什么本质区别和联系

1. 类方法属于类对象，用“+”号修饰，它类似于C语言中的静态方法，类方法列表定义在类对象的元类中，通过isa指针找到；实例方法属于实例对象，用“-”号修饰，实例方法列表定义在实例对象的类对象中，通过isa指针找到。
2. 类方法只能通过类对象调用，也就是类名直接调用；实例方法则需要由通过alloc和init方法实例化后的实例对象调用。
3. 类方法中的self指类对象；实例方法中的self指实例对象。
4. 类方法可以调用其他的类方法，但不可以直接调用实例方法；而实例方法既可以调用其他实例方法，也可以通过类名直接调用本类或者外部类的类方法。
5. 在实例方法中可以访问成员变量，但类方法中不能访问成员变量。



###### 5.子类初始化时为什么要调用self=[superinit]

因为子类继承自父类，需要获得父类的实例和方法等，所以初始化子类之前要先保证父类已经初始化完毕，防止出错。当调用self=[super init]方法时，如果父类初始化不成功，那么会返回nil，所以可以根据self是否为nil判断父类是否初始化成功，从而进行合理地处理，以便起到容错效果。



###### 6.使用dealloc方法释放对象时，为什么一定要调用[superdealloc]方法?在何处调用?

因为子类的很多实例变量是继承自父类的，所以要调用[superdealloc]方法来释放从父类继承来的实例变量，实际上还是释放自己的实例变量，只是继承来的这部分只能调用父类的dealloc方法来释放。

按照自下往上的逻辑，一般要先释放子类的实例，然后释放父类的实例。自下往上的原因是，在调用[super dealloc]方法之前如果不先把子类中的变量从内存中释放掉，容易造成子类中变量的内存积压，导致内存泄漏，所以[super dealloc]方法应该在释放掉子类变量之后最后调用。



###### 7. ＃import与＃include以及＃import<>与＃import""各有什么区别

import与#include都是用来引入头文件的。与#include相比，Objective-C中#import的优势是不会引起重复包含，相当于多了C/C++中#pragma once的作用，它可以保证头文件只被编译一次。

import<>与#import""的区别和C/C++中#include<>与#include""的区别一样：使用尖括号<>指用来引入系统的头文件，而使用引号" "指用来引入本地用户头文件。



###### 8.Objective-C中@class代表什么

@class相当于只是在头文件声明一下要用到的类的头文件（前向声明），告诉编译器有这样一个类的定义但暂时不要将类的实现引入，让该类定义的变量能够编译通过，直到运行起来时才去查看类的实现文件。但实际上这样也只能起到在头文件中声明该类实例变量的作用，在.m文件中如果用到类的实现细节（属性和方法），那么还是要通过#import再次引入类的头文件。

使用@class的好处是将头文件的引入延迟了，至少延迟到了.m实现文件中，这也符合“直到真正用到的时候再确定引入”的动态思想，尽量往后拖延，更重要的是这样也可以有效地避免头文件的重复引入甚至循环引用等问题。



###### 9.Objective-C中有二维数组吗？如何实现

Objective-C中是没有二维数组的。二维数组是通过一维数组的嵌套实现的。



###### 10.在Objective-C的数组或字典中，添加nil对象会有什么问题

数组或字典如果通过addObject方法添加nil，那么程序会崩溃。

但如果使用initWith Objects方法来初始化数组，其中的nil会被编译器过滤去掉，不会出现崩溃问题。

另外，如果使用糖衣语法初始化数组或字典，那么也不可以有nil，此时nil不会被过滤掉也会导致程序崩溃。



###### 11. Objective-C中的可变和不可变类型是什么？

Objective-C中的mutable和immutable类型对应于动态空间分配和静态空间分配。



###### 12.以下这个写法会出什么问题?

```
@property(nonatomic, copy) NSMutableArray *array;
```

这里可变数组变量的内存管理语义修饰词设置为copy，而使用copy策略复制出来的是一个NSArray不可变数组对象，把copy出来的不可变数组对象当成可变数组对象使用容易造成程序崩溃。



###### 13. 在Objective-C中，常量有哪几种类型

1. 整型常量
2. 浮点型常量
3. 字符常量
4. 符号常量(#define 标识符常量)



###### 14. 常量和变量有什么区别?

在Objective-C中，用来指代数据的值有可变和不可变之分。

常量表示一些固定的、不会被修改的数据。反之，能改变的数据的值就称为变量。



###### 15. Objective-C中的NSInteger类型和C语言中的int类型有什么区别

在Objective-C中，数据类型可以分为基本数据类型、对象类型和id类型。

基本数据类型有int类型、float类型、double类型、char类型、布尔类型等。

事实上，Objective-C中的NSInteger也是基本数据类型之一。

在苹果的API实现中，NSInterger是一个对int类型和long类型的封装，它会识别当前操作系统的位数，自动返回最大的类型。

NSInteger是long或者int的别名，对应的NSUInteger是unsigned long或者unsigned int的别名。区别在于，NSInteger会根据系统是32位机还是64位机来动态确定自身是整型还是长整型，从而可以很好地兼容两种机器。因此，当开发者不知道操作系统是什么类型的时候，通常应该使用NSInteger，这也是苹果公司推荐使用的基本数据类型之一。

NSInteger是Objective-C基本数据类型，不是NSNumber的子类，也不是NSObject的子类。



###### 16. NSNumber与NSInteger有什么区别

NSInteger和NSNumber最本质的区别是：NSInteger不是一个对象，而是基本数据类型的typedef（也就是基本数据类型另外的一个名称）。它实际上是64位的long或者32位的int。

如果需要存储一个数值（如将一个int类型的值存入数组），那么直接使用NSInterger是不行的，必须使用NSNumber类将基本数据类型包装成对象。































