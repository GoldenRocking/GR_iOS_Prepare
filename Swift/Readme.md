#### 为类型取别名Swift Tips:



###### 1. 元组

* 元组允许一些并不相关的类型进行自由组合成为新的集合类型

  ``` 
  var pen:(name:String, price:Int) = ("钢笔",1)
  print(pen.name)
  print(pen.price)
  ```

* 在创建元组时，也可以不指定元组中参数的名称，元组会自动为每个参数分配下标，下标值将从0开始依次递增。

  ```
  var car:(String, Int) = ("BMW", 100086)
  print(car.0)
  print(car.1)
  ```

* 元组实例被创建后，可以通过指定的变量或者常量来分解它:

  ~~~
  var (theName, thePrice) = car
  print(theName)
  print(thePrice)
  ~~~

* 有些时候，开发者可能并不需要获取某个元组实例中所有元素的值，这种情况下，开发者也可以将某些不需要获取的元素使用匿名的方式来接收

  ```
  var (name,_) = car
  print(name)
  ```

* 在Swift语言中，常常使用符号“_”来表示匿名的概念，因此“_”也被称为匿名标识符。

* 元组虽然使用起来十分方便，然而其只适用于简单数据的组合，对于结构复杂的数据，要采用结构体或者类来实现。

  

###### 2. 可选值类型

* 在Swift语言中普通的类型是不允许为nil的，如果一个变量在逻辑上可能为nil，则开发者需要将其包装为Optional类型。

  ~~~
  var obj: String?
  if(obj == nil){
      print("aaa")
  }
  ~~~

* Optional类型不会独立存在，其总是会附着于某个具体的数据类型之上，具体的数据类型可以是基本数据类型，可以是结构体，也可以是类等。

* 如果其附着类型对应的量值有具体的值，则其为具体值的包装。

* 如果其附着类型对应的量值没有具体的值，则其为nil。

* Optional类型中的nil读者也可以理解为一种值。

* Optional类型是对普通类型的一种包装，因此在使用的时候也需要对其进行拆包操作，拆包将使用到Swift中的操作符“! ”。

  ~~~
  var obj: String? = "HS"
  if(obj != nil){
      print(obj!)
  }
  ~~~

* 在使用“! ”进行Optional值的拆包操作时，必须保证要拆包的值不为nil，否则程序运行会出错。

* Swift语言还提供了一种if-let语法结构来进行Optional类型值的绑定操作

  ```
  if let tmp = obj {
      print(tmp)
  }else{
      obj = "Lucy" 
      print(obj!)
  }
  ```

* 上面的代码可以这样理解：如果obj有值，则if-let结构将创建一个临时常量tmp来接收obj拆包后的值，并且执行if为真时所对应的代码块，在执行的代码块中，开发者可以直接使用拆包后的obj值tmp。如果obj为nil，则会进入if为假的代码块中，开发者可以在else代码块中将obj重新赋值使用。

* if-let结构中也可以同时进行多个Optional类型值的绑定，之间用逗号隔开

  ```
  var obj1:Int? = 1, obj2:Int? = 2
  if let tmp1 = obj1,let tmp2 = obj2{
      print(tmp1,tmp2)
  }
  ```

* 在同时进行多个Optional类型值的绑定时，只有所有Optional值都不为nil，绑定才会成功，代码执行才会进入if为真的代码块中。

##### 

###### 3. 为类型取别名

* Swift语言中使用typealias关键字来为某个类型取一个别名

  ```
  typealias Price = Int
  var penPrice:Price = 10 
  ```

* 灵活使用typealias为类型取别名可以优化代码的可读性。 



###### 4.字符串组合

* Swift中的Sring类型对“+”运算符进行了重载实现，即开发者可以直接使用“+”符号将多个字符串组合拼接为新的字符串。

  ```
  var c1 = "Hello"
  var c2 = "World"
  var c3 = c1 + " " + c2
  ```

*  除了可以使用格式化的构造方法外，Swift中还提供了一种十分方便的字符串插值方法，示例如下：

  ```
  var d = "Hello \(c2)"
  ```

*  “\()”结构可以将其他数据类型转换为字符串类型并且插入字符串数据的相应位置。



###### 5.空合并运算符

* 空合并运算符是针对可选类型而设计的运算符。

  ```
  var q: Int? = 8
  var value:Int
  if q != nil{
      value = q!
  }else{
      value = 0
  }
  ```

  上述代码等价于：

  ```
  var q:Int? = 8
  var value:Int
  value = q ?? 0
  ```

* 空合并运算符“? ? ”是一个二元运算符。
* 其需要两个操作数，第一个操作数必须为一个Optional值，如果此Optional值不为nil，则将其进行拆包操作，并作为空合并运算的运算结果。如果此Optional值为nil，则会将第二个操作数作为空合并操作运算的结果返回。



###### 6.区间运算符

* Swift提供了一个区间运算符来快捷直观地表示范围区间。

  ```
  //创建范围 >=0 且 <=10 的闭区间
  var range1 = 0...10
  
  //创建范围 >=0 且 <10 的半开区间
  var range2 = 0..<10
  ```

* 也可以通过“~=”运算符来检查某个数字是否包含于范围中

  ```
  //8是否在range1中
  print(range1~=8)
  ```

  ```
  for index in 1...5 {
      print(index)
  }
  ```

* Swift中使用“_”符号来表示匿名参数

  ```
  
  var sum = 0
  for _ in 1...3 {
      sum += 1
  }
  ```

  

###### 7. Switch

* 在C/Objective-C语言中，case语句不会因匹配成功而中断，如果不进行手动控制，switch结构中的case子句会依次进行匹配执行。

* Swift语句优化了这一点，一个case语句匹配成功后，会自动跳出switch结构，如果不加特殊处理，switch结构中的分支只会被执行一个或者一个也不执行。 



###### 8.流程跳转

* fallthrough语句是Swift中特有的一种流程控制语句。

* Swift语言中的switch-case结构匹配到一个case后，会自动中断后面所有case的匹配操作，如果在实际开发中，需要switch-case结构不自动进行中断操作，可以使用fallthrough语句。

  ```
  var tuple = (0,0)
  switch tuple {
  case (0,0):
      print("Sure")
      fallthrough
  case(_,0):
      print("Sim")
      fallthrough
  case(0...3,0...3):
      print("SIM")
  default:
      print("")
  }
  ```

* guard-else语句也被称为守护语句，顾名思义，其作用就是确保某个条件成立才允许其后的代码执行

  ```
  func funcOne(param:Int){
      guard param > 0 else {
          return
      }
      
      print("guard")
  }
  ```



* ###### 9.函数

  * Swift语言中引入了参数的内部命名与外部命名概念。内部命名在函数实现时使用，外部命名在函数调用时使用。

  * 开发者若不设置参数的外部命名，则默认函数参数的外部命名与内部命名相同。

  * Swift语言也支持省略函数参数的外部名称，默认函数参数的外部名称与内部名称相同，开发者可以使用匿名变量标识符“_”来对外部名称进行省略。

  * Swift语言中函数的参数也支持设置默认值。需要注意的是，如果函数的某个参数设置了默认值，那么开发者在调用函数的时候，可以传此参数的值，也可以不传此参数的值，但是参数的位置要严格对应。

  * 实际上在Swift语言中，在某个参数类型的后面追加符号“…”，则会将此参数设置为数量可变。在函数内部，开发者传递的值会被包装成一个集合类型赋值给对应参数。需要注意，传递的参数类型必须相同，并且可以传递多组数量可变的参数，不同参数之间参数类型可以不同。

  * ```
    func myFunc11(param1:Int...,param2:String){
        var sum = 0;
        for count in param1{
            sum += count
        }
        
        print("\(param2):\(sum)")
    }
    
    myFunc11(param1: 1,2,4, param2: "Swift")
    ```

  * 关于Swift语言的参数传递，还有这样一个特点：传递的如果是值类型的参数，那么参数值在传递进函数内部时会将原值拷贝为一份常量，且在函数内不可以修改。

  * 类属于引用类型，而基本数据类型、枚举和结构体都属于值类型。

  * 如果在开发中真的需要在函数内部修改传递参数的变量的值，可以将此参数声明为inout类型。

    ```
    func myFunc12(param:inout Int){
        param+=1
    }
    
    var para = 10;
    myFunc12(param: &para)
    print(para)
    ```

  * 闭包的实质是一段有具体功能的代码块，其结构为{(param1, param2, …) in代码块}，其最外面由大括号包围，内部小括号为参数列表，in为闭包关键字，之后需要编写实现相应功能的代码。

  * 也可以通过一个函数来对函数变量进行赋值

    ```
    var addFunc:(Int, Int)->Int
    
    func myFunc13(param1:Int, param2:Int)->Int {
        return param1 + param2
    }
    
    addFunc = myFunc13
    addFunc(1,2)
    ```

  * 函数也可以作为另一个函数的参数:

    ```
    func myFunc14(param:(Int,Int)->Int){
        print(param(1,2))
    }
    
    myFunc14(param: addFunc)
    ```

  * 函数也可以作为返回值来使用

    ```
    func myFunc15()->(Int, Int)->Int{
        return {(param1:Int, param2:Int)
        in
            return param1 + param2 + 10
        }
    }
    
    addFunc = myFunc15()
    addFunc(1,2)
    ```

  * 闭包的设计大多数情况下并不是为了代码的复用，而是传递功能代码块和处理回调结构。

  * 闭包的最外层由大括号包围，内部由闭包关键字in来进行分割，关键字in前面为闭包结构的参数列表和返回值，其书写规则与函数一致，in关键字后面为闭包体，用于实现具体功能。
  * 当函数中的最后一个参数为闭包参数时，在调用函数时，开发者可以将闭包结构脱离出函数的参数列表，追加在函数的尾部，增强代码的可读性。
  * 逃逸闭包是指函数内的闭包在函数执行结束后在函数外依然可以进行使用，非逃逸闭包是指当函数的生命周期结束后，闭包也将被销毁。
  * 逃逸类型的闭包常用于异步操作中，例如一个后台请求完成后要执行闭包回调，需要使用逃逸类型。

  



* ###### 10.属性/方法

  *  存储属性与计算属性的区别在于，存储属性用于描述存储值，计算属性用于描述计算过程并获取计算结果。
  *  计算属性中可以定义get与set方法，分别用来获取计算属性的值和设置计算属性的值。
  * 关于计算属性的get与set方法，需要注意，get方法是必不可少的，而set方法是可选的。 
  *  当一个计算属性只有get方法而没有set方法时，此计算属性是只读的，外界只能获取此计算属性的值，不能设置此计算属性的值。
  *  属性监听器用于监听存储属性赋值的过程，并且开发者可以在其中编写代码，添加额外的逻辑。
  * 在进行属性的构造或初始化时，无论是通过构造方法进行的属性构造或初始化还是通过为属性设置默认值，都不会调用属性监听器的方法。初始化后从第2次为属性赋值开始，属性监听器才会被调用。
  * 实例属性由类的实例调用，类属性则是直接由类来调用。
  * 使用static关键字声明的属性也被称为静态属性，需要注意，对于类计算属性，如果允许子类对其计算方法进行覆写，则需要用class关键字来声明。
  *  实例方法是由类型的实例进行调用的，类方法是由类型名直接调用的。
  * Swift语言中的类型有值类型与引用类型之分，对于引用类型，在实例方法中对实例属性进行修改是没问题的。但是对于值类型，读者需要格外注意，使用mutating关键字修饰实例方法才能对属性进行修改。
  *  Swift语言中的类方法也是通过static和class关键字来声明的，static关键字声明的类方法又被称为静态方法，其不能被子类覆写，而class关键字声明的类方法可以被类的子类覆写。
  *  Swift语言中所有的构造方法都需要使用init()来标识。
  * 如果某个属性在逻辑上是允许为nil的，开发者可以将其声明成Optional可选值类型，对于Optional类型的属性，如果在构造方法中不进行赋值，则会被默认赋值为nil。
  *  在继承关系中，如果子类没有覆写或者重写任何指定构造方法，则默认子类会继承父类所有的指定构造方法。
  * 如果子类中提供了父类所有的指定构造方法（无论是通过继承方式还是覆写方式），则子类会默认继承父类的便利构造方法。
  * 构造方法使用init()来标识，析构方法使用deinit()来标识。



* ###### 11. 结构体/类

  * Objective-C语言中，结构体中只可以定义属性而不能定义方法。在Swift语言中，结构体和类十分相似，其中既可以定义属性，也可以定义方法，但其不像类一样具有继承的特性。

  * 结构体、枚举以及前面读者接触到的除类以外的所有数据类型都属于值类型。只有类是引用类型的。
  * 值类型数据和引用类型数据最大的区别在于当进行数据传递时，值类型总是被复制，而引用类型不会被复制，引用类型是通过引用计数来管理其生命周期的。
  *  在结构体中开发者并不需要提供构造方法，结构体会根据属性自动生成一个构造方法，而类则要求开发者自己提供构造方法，在init()构造方法中，需要完成对类中所有属性的赋值操作。

  * final关键字用于修饰某些终极的属性、方法或者类。被final修饰的属性和方法不能够被子类覆写。 
  *  如果不希望某个类被继承，也可以使用final关键字来修饰这个类，使其成为终极类。
  *  苹果公司官方推荐开发者在如下情况下使用结构体来描述数据：
    * 要描述的数据类型其中只有少量的简单数据类型的属性。
    * 要描述的数据类型在数据传递时需要以复制的方式进行。
    * 要描述的数据类型中的所有属性在进行传递时需要以复制的方式进行。
    * 不需要继承另一个数据类型。
  * 如果要对值类型进行比较操作，应使用等于运算符“==”；对引用类型进行比较操作，应使用等同运算符“===”
  * 在Swift语言中，Array、String、Dictionary、Set这些数据类型都是采用结构体来实现的，这点和Objective-C有着很大的区别。 



* ###### 12.内存管理

  * Swift语言中提供了弱引用关键字weak来避免循环引用的问题，weak关键字的作用是在使用这个实例的时候并不保有此实例的引用。这样来说，普通的引用类型数据在传递时会使实例的引用计数加1，使用weak关键字修饰的引用类型数据在传递时不会使引用计数加1。
  * 弱引用有一个特点，其只能修饰Optional类型的属性，被弱引用的实例释放后，这个属性会被自动设置为nil。
  *  Swift语言中还提供了一个关键字unowned（无主引用）来处理非Optional值类型属性的循环引用问题。
  *  无主引用与弱引用的最大区别在于，无主引用总是假定属性是不为nil的，如果属性所引用的实例被销毁释放了，再次使用这个实例程序会直接崩溃。而弱引用则允许属性值为nil，如果属性所引用的示例被销毁释放了，此属性会当成Optional值nil来处理，不会崩溃。
  *  如果在闭包属性中使用到self关键字，就会对当前类实例本身进行引用计数加1。由于此闭包又是当前类的一个属性，闭包属性无法销毁，则当前类实例也就无法销毁。反过来，当前类实例无法销毁，闭包属性也无法销毁。如此产生循环引用，将造成内存泄漏。
  * Swift语言专门为闭包结构提供了捕获列表，来对闭包内使用到的变量或者实例进行弱引用或无主引用的转换。
  *  捕获列表在结构上需要紧跟在闭包的起始大括号后，使用中括号包围。
  *  如果闭包的捕获列表中需要对多个引用类型的量值进行引用转换，使用逗号进行分割即可。
  *  
  *  